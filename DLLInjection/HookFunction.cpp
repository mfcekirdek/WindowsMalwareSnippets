// HookFunctionExample.cpp : This file contains the 'main' function. Program execution begins and ends there.
// 32 bit !!!

#include "pch.h"
#include <iostream>
#include <windows.h>
#include <stdio.h>

BOOL HookFunction(LPCWSTR moduleName, LPCSTR funcName, LPVOID funcProxy, unsigned char* lpBackup);
void metod();
void f(LPVOID s);

typedef void(__stdcall *f_func)();

int main()
{
    std::cout << "Hello World!\n"; 
	// HookFunction(L"ws2_32.dll", "recv", NULL,NULL);
	unsigned char* hookR = NULL;
	HMODULE hModDLL = LoadLibrary(L"C:\\DLLForHookFunction.dll");
	f_func func = (f_func) GetProcAddress(hModDLL, "mydllmain");
	if (func != NULL) {
		
		printf("BEFORE HOOKING: \n");
		func();
		//getchar();

		HookFunction(L"C:\\DLLForHookFunction.dll", "mydllmain", (LPVOID*)metod, hookR);

		//func = (f_func)GetProcAddress(hModDLL, "mydllmain");

		if (func != NULL) {
			printf("AFTER HOOKING: \n");
			func();
		}

	}

}

void metod() {
	MessageBox(0, L"YOU ARE HOOKED!", 0, 0);
}




BOOL HookFunction(LPCWSTR moduleName, LPCSTR funcName, LPVOID funcProxy, unsigned char* lpBackup) {

	BYTE jmp[6] = { 0xe9,0x00,0x00,0x00,0x00,  /*JMP and 4 bytes of offset*/
				   0xc3 /*RET*/
	};

	/*
   JMP (e9) is relative, its 32-bit signed immediate operand encodes the
   number of bytes to jump forward relative to the NEXT instruction.
   Yani e9'dan sonra gelen 4 byte'Lik offset degeri NEXT instruction'dan kac byte sonraya atlanacagini belirtir.
   */

   /* Get the target address of the function to hook */
	LPVOID funcAddr = (LPVOID)GetProcAddress(LoadLibrary(moduleName), funcName);
	//wprintf(L"funcAddr = %02X \n", funcAddr);

	// save original first 6 bytes of function
	BYTE bArr[6] = {};
	memcpy(bArr, funcAddr, 6);
	printf("Original first 6 bytes of function: 0x%X --> %02X[%02X%02X%02X%02X]%02X\n", funcAddr, bArr[0], bArr[1], bArr[2], bArr[3], bArr[4], bArr[5]);



	//getchar();
	/* Code is not necessarily mapped as writable, we remap it */
	DWORD prev;
	int res = VirtualProtect(funcAddr, 6, PAGE_EXECUTE_READWRITE, &prev);
	if (res == 0)
		printf("\n ERROR : %d", GetLastError());
	/* Read the original 6 bytes we are going to overwrite */
	ReadProcessMemory(GetCurrentProcess(), funcAddr, lpBackup, 6, NULL);

	/*
		Compute the offset: target - source
		target = funcProxy
		source = funcAddr + 5 (length of JMP)

		target - source = funcProxy - funcAddr - 5
	*/

	DWORD dwProxy = ((DWORD)funcProxy - (DWORD)funcAddr) - 5;
	LPVOID proxy = (LPVOID)dwProxy;


	/* We need to change 6 bytes at funcAddr address. funcAddr hooklayacagimiz metodun basladigi adresi tutuyor icinde.
	Biz de funcAddr'nin icinde tutulan adrese gidip ilk 6 byte'i degistirecegiz.
	*/
	printf("##### Address of funcAddr variable: %02X, Value of funcAddr variable:%02X\n", &funcAddr, funcAddr);
	printf("##### Address of jmp array: %02X, Values of jmp array:%02X[%02X%02X%02X%02X]%02X\n", jmp, jmp[0], jmp[1], jmp[2], jmp[3], jmp[4], jmp[5]);

	/*
	   Create the JMP instruction: set the offset
	   Atlanacak offseti jmp'in sonuna ekliyor.
	*/
	memcpy(&jmp[1],&proxy, 4);

	printf("JMP Offset is set..\n");
	printf("##### New Address of jmp array: %02X, New Values of jmp array:%02X[%02X%02X%02X%02X]%02X\n", jmp, jmp[0], jmp[1], jmp[2], jmp[3], jmp[4], jmp[5]);

	/* Overwrite the first 6 bytes of the target function */
	memcpy((LPVOID)funcAddr, jmp, 6);

	memcpy(bArr, funcAddr, 6);

	printf("New first 6 bytes of function: 0x%X --> %02X[%02X%02X%02X%02X]%02X\n", funcAddr, bArr[0], bArr[1], bArr[2], bArr[3], bArr[4], bArr[5]);
	printf("This means:\tjmp [%02X%02X%02X%02X%] \n\t\t ret\n", jmp[1], jmp[2], jmp[3], jmp[4]);


	/* Reset the memory protection to its original value*/
	VirtualProtect((LPVOID)funcAddr, 6, prev, &prev);

	/* Since we write to a code section with DS, flush the L1 I cache */
	FlushInstructionCache(GetCurrentProcess(), NULL, NULL);

	return TRUE;
}


